cbuild-run:
  generated-by: csolution version 2.9.0
  solution: PowerManage.csolution.yml
  target-type: PowerManage
  compiler: AC6
  device: STMicroelectronics::STM32L011D4Px
  device-pack: Keil::STM32L0xx_DFP@3.0.0
  output:
    - file: out/PowerManage/PowerManage/PowerManage.axf
      info: generate by PowerManage+PowerManage
      type: elf
      load: image+symbols
  system-resources:
    memory:
      - name: Flash
        access: rx
        start: 0x08000000
        size: 0x00004000
        from-pack: Keil::STM32L0xx_DFP@3.0.0
      - name: SRAM
        access: rwx
        start: 0x20000000
        size: 0x00000800
        from-pack: Keil::STM32L0xx_DFP@3.0.0
  system-descriptions:
    - file: ${CMSIS_PACK_ROOT}/Keil/STM32L0xx_DFP/3.0.0/CMSIS/SVD/STM32L0x1.svd
      type: svd
  debugger:
    name: CMSIS-DAP@pyOCD
    protocol: swd
    clock: 10000000
    dbgconf: .cmsis/PowerManage+PowerManage.dbgconf
    gdbserver:
      - port: 3333
  debug-vars:
    vars: |
      __var DbgMCU_CR      = 0x00000006;   // DBGMCU_CR:  DBG_STOP, DBG_STANDBY
      __var DbgMCU_APB1_Fz = 0x00000000;   // DGBMCU_APB1_FZ: All Peripherals Operate as in Normal Mode
      __var DbgMCU_APB2_Fz = 0x00000000;   // DGBMCU_APB2_FZ: All Peripherals Operate as in Normal Mode
      __var DoOptionByteLoading = 0;       // Disabled
  debug-sequences:
    - name: DebugDeviceUnlock
      blocks:
        - execute: |
            Sequence("CheckID");
    - name: DebugCoreStart
      blocks:
        - execute: |
            // Replication of Standard Functionality
            Write32(0xE000EDF0, 0xA05F0001);                                        // Enable Core Debug via DHCSR
        - info: DbgMCU registers
          execute: |
            // Device Specific Debug Setup
            Write32(0x40021034, Read32(0x40021034) | 0x00400000);                   // Set RCC_APB2ENR.DBGEN

            Write32(0x40015804, DbgMCU_CR);                                         // DBGMCU_CR: Configure MCU Debug
            Write32(0x40015808, DbgMCU_APB1_Fz);                                    // DBGMCU_APB1_FZ: Configure APB1 Peripheral Freeze Behavior
            Write32(0x4001580C, DbgMCU_APB2_Fz);                                    // DBGMCU_APB1_FZ: Configure APB2 Peripheral Freeze Behavior
    - name: CheckID
      blocks:
        - execute: |
            __var pidr1 = 0;
            __var pidr2 = 0;
            __var jep106id = 0;
            __var ROMTableBase = 0;

            __ap = 0;      // AHB-AP

            ROMTableBase = ReadAP(0xF8) & ~0x3;

            pidr1 = Read32(ROMTableBase + 0x0FE4);
            pidr2 = Read32(ROMTableBase + 0x0FE8);
            jep106id = ((pidr2 & 0x7) << 4 ) | ((pidr1 >> 4) & 0xF);
        - if: jep106id != 0x20
          execute: |
            Query(0, "Not a genuine ST Device! Abort connection", 1);
            Message(2, "Not a genuine ST Device! Abort connection.");
    - name: DebugPortStop
      blocks:
        - execute: |
            __var connectionFlash = ( __connection & 0xF ) == 2 ;
            __var FLASH_BASE = 0x40022000 ;
            __var FLASH_CR = FLASH_BASE + 0x04 ;
            __var OBL_LAUNCH_BIT = ( 1 << 18 ) ;
            __var LOCK_BIT = ( 1 << 0 ) ;
            __var OPTLOCK_BIT = ( 1 << 2 ) ;
            __var FLASH_KEYR = FLASH_BASE + 0x0C ;
            __var FLASH_KEY1 = 0x89ABCDEF ;
            __var FLASH_KEY2 = 0x02030405 ;
            __var FLASH_OPTKEYR = FLASH_BASE + 0x14 ;
            __var FLASH_OPTKEY1 = 0xFBEAD9C8 ;
            __var FLASH_OPTKEY2 = 0x24252627 ;
            __var FLASH_CR_Value = 0 ;
            __var DoDebugPortStop = 1 ;
            __var DP_CTRL_STAT = 0x4 ;
            __var DP_SELECT = 0x8 ;
        - if: connectionFlash && DoOptionByteLoading
          blocks:
            - execute: |
                // unlock the FLASH_CR
                Write32( FLASH_KEYR, FLASH_KEY1 ) ;
                Write32( FLASH_KEYR, FLASH_KEY2 ) ;
                // unlock the option byte block
                Write32( FLASH_OPTKEYR, FLASH_OPTKEY1 ) ;
                Write32( FLASH_OPTKEYR, FLASH_OPTKEY2 ) ;
                FLASH_CR_Value = Read32( FLASH_CR ) ;
            - if: "!( FLASH_CR_Value & ( ( LOCK_BIT ) | ( OPTLOCK_BIT ) ) )"
              execute: |
                DoDebugPortStop = 0 ;
                __errorcontrol = 1 ;
                // write OBL_LAUNCH bit (causes a reset)
                Write32( FLASH_CR, FLASH_CR_Value | ( OBL_LAUNCH_BIT ) ) ;
                __errorcontrol = 0 ;
        - if: DoDebugPortStop
          execute: |
            // Switch to DP Register Bank 0
            WriteDP(DP_SELECT, 0x00000000);
            // Power Down Debug port
            WriteDP(DP_CTRL_STAT, 0x00000000);
  programming:
    - algorithm: ${CMSIS_PACK_ROOT}/Keil/STM32L0xx_DFP/3.0.0/CMSIS/Flash/STM32L0xx_16.FLM
      start: 0x08000000
      size: 0x00004000
      ram-start: 0x20000000
      ram-size: 0x00000800
